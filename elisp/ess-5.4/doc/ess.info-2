This is ess.info, produced by makeinfo version 4.2 from ess.texi.

ESS -- Emacs Speaks Statistics
******************************

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* ESS: (ess). Emacs Speaks Statistics (S/S+/R, SAS, BUGS/JAGS, Stata, XLisp-Stat).
END-INFO-DIR-ENTRY


File: ess.info,  Node: Manual,  Prev: Latest version,  Up: Introduction

How to read this manual
=======================

   If you need to install ESS, read *Note Installation:: for details on
what needs to be done before proceeding to the next chapter.

   In this manual we use the standard notation for describing the
keystrokes used to invoke certain commands.  `C-<chr>' means hold the
CONTROL key while typing the character <chr>. `M-<chr>' means hold the
META or EDIT or ALT key down while typing <chr>. If there is no META,
EDIT or ALT key, instead press and release the ESC key and then type
<chr>.

   All ESS commands can be invoked by typing `M-x command'.  Most of
the useful commands are bound to keystrokes for ease of use.  Also, the
most popular commands are also available through the emacs menubar, and
finally, if available, a small subset are provided on the toolbar.
Where possible, keybindings are similar to other modes in emacs to
strive for a consistent user interface within emacs, regardless of the
details of which programming language is being edited, or process being
run.

   Some commands, such as `M-x R' can accept an optional `prefix'
argument.  To specify the prefix argument, you would type `C-u' before
giving the command.  e.g. If you type `C-u M-x R', you will be asked
for command line options that you wish to invoke the R process with.

   Emacs is often referred to as a `self-documenting' text editor.  This
applies to ESS in two ways.  First, limited documentation about each ESS
command can be obtained by typing `C-h f'.  For example, if you type
`C-h f ess-eval-region', documentation for that command will appear in
a separate *Help* buffer.  Second, a complete list of keybindings that
are available in each ESS mode and brief description of that mode is
available by typing `C-h m' within an ESS buffer.

   Emacs is a versatile editor written in both C and lisp; ESS is
written in the Emacs lisp dialect (termed `elisp') and thus benefits
from the flexible nature of lisp.  In particular, many aspects of ESS
behaviour can be changed by suitable customization of lisp variables.
This manual mentions some of the most frequent variables.  A full list
of them however is available by using the Custom facility within emacs.
(Type `M-x customize-group RET ess RET' to get started.)  *Note
Customization:: provides details of common user variables you can
change to customize ESS to your taste, but it is recommended that you
defer this section until you are more familiar with ESS.


File: ess.info,  Node: Installation,  Next: Interactive ESS,  Prev: Introduction,  Up: Top

Installing ESS on your system
*****************************

   The following section details those steps necessary to get ESS
running on your system.

* Menu:

* Unix installation::              Installing ESS on your Unix system
* Microsoft Windows installation:: Installing ESS on your MS Windows system
* Requirements::         emacs, Operating Systems and Statistical Packages


File: ess.info,  Node: Unix installation,  Next: Microsoft Windows installation,  Up: Installation

Unix installation
=================

   For a Unix or Unix-like installation, please follow the next steps.
Retrieve the latest tgz file (`ess-VERSION.tgz') from ESS downloads
area (http://ess.r-project.org/index.php?Section=download).

   _GNU Emacs Simple Instructions:_ for recent versions of Emacs (22.x
or higher) and ESS, the installation process is simple.

  1. Extract all the files from `ess-VERSION.tgz' when you are in the
     current working directory of `/usr/local/share/emacs/site-lisp'
     which exists for packages like ESS (or for Mac OS X
     `/Applications/Emacs.app/Contents/MacOS/Resources/site-lisp'):
          %prompt gtar zxf ess-VERSION.tgz            # for GNU tar
          %prompt gunzip < ess-VERSION.tgz | tar xf - # for Unix tar

  2. Then, add the line
          (require 'ess-site)
     to `~/.emacs' and restart Emacs.

  3. If you see a buffer named `*ESS*', then the simple instructions
     were most likely successful.  If not, then read further.

  4. It could be that you have an older version of Emacs, some other
     problem with your installation or you are not a sysadmin.
     Whatever the case, you may need to edit `ess-site.el' manually.
     If that is the case, then you should create a directory just for
     ESS like `~/ess' or `/usr/local/ess' and unpack ESS there.  That
     way, your changes to `ess-site.el' will not be lost if you update
     Emacs later.

  5. Replace the line above with
          (load "~/ess/ess-VERSION/lisp/ess-site")
     in `~/.emacs' and restart Emacs.

  6. If you see a buffer named `*ESS*', then the manual instructions
     were most likely successful.  If not, then send a query to
     <ess-help-request@stat.math.ethz.ch> explicitly describing your
     problem and your environment including operating system, Emacs
     version, ESS version, etc.

   _XEmacs Simple Instructions:_ for recent versions of XEmacs (21.x or
higher) and ESS, the installation process is simple.

  1. Extract all the files from `ess-VERSION.tgz' when you are in the
     current working directory of
     `/usr/local/LOCATION/xemacs/site-packages' which exists for
     packages like ESS where `LOCATION' is `lib' for legacy
     installations and `share' now (or for Mac OS X
     `/Applications/XEmacs.app/Contents/MacOS/Resources/site-packages'):
          %prompt gtar zxf ess-VERSION.tgz            # for GNU tar
          %prompt gunzip < ess-VERSION.tgz | tar xf - # for Unix tar

  2. Then, add the line
          (require 'ess-site)
     to `~/.xemacs/init.el' and restart XEmacs.

  3. If you see a buffer named `*ESS*', then the simple instructions
     were most likely successful.  If not, then read further.

  4. It could be that you have an older version of XEmacs, some other
     problem with your installation or you are not a sysadmin.
     Whatever the case, you may need to edit `ess-site.el' manually.
     If that is the case, then you should create a directory just for
     ESS like `~/ess' or `/usr/local/ess' and unpack ESS there.  That
     way, your changes to `ess-site.el' will not be lost if you update
     XEmacs later.

  5. Replace the line above with
          (load "~/ess/ess-VERSION/lisp/ess-site")
     in `~/.xemacs/init.el' and restart XEmacs.

  6. If you see a buffer named `*ESS*', then the manual instructions
     were most likely successful.  If not, then send a query to
     <ess-help-request@stat.math.ethz.ch> explicitly describing your
     problem and your environment including operating system, XEmacs
     version, ESS version, etc.

  1. (OPTIONAL) COMPILING E-LISP:

     Edit the default locations of `LISPDIR', `INFODIR' and `ETCDIR' in
     Section 1 of `Makeconf' (if you are using XEmacs, then edit the
     XEmacs subsection in Section 1).

     You can compile those files by:
          make all

     When that completes successfully, install the compiled files:
          make install



File: ess.info,  Node: Microsoft Windows installation,  Next: Requirements,  Prev: Unix installation,  Up: Installation

Microsoft Windows installation
==============================

   For Microsoft Windows installation, please follow the next steps.
Retrieve the latest zip file (`ess-VERSION.zip') from ESS downloads
area (http://ess.r-project.org/index.php?Section=download).

   _GNU Emacs Simple Instructions:_ for recent versions of Emacs (22.x
or higher) and ESS, the installation process is simple.

  1. Extract all the files from `ess-VERSION.zip' (by double clicking
     on it and selecting "Extract all files" which launches the Folders
     Extraction Wizard) into the `site-lisp' directory that exists for
     packages like ESS.  If GNU Emacs was installed in the default
     location, then this directory can be found somewhere like
     `C:\Program Files\GNU Emacs\emacs-22.x\site-lisp'.

  2. Add the line
          (require 'ess-site)
     to `~/.emacs' and restart Emacs.

  3. If you see a buffer named `*ESS*', then the simple instructions
     were most likely successful.  If not, then read further.

  4. It could be you have an older version of Emacs or some other
     problem with your installation.  Either way, you may need to edit
     `C:\ess\ess-VERSION\lisp\ess-site.el' manually.  If that is the
     case, then you should create a directory just for ESS like
     `C:\ess' and unpack ESS there.  That way, your changes to
     `C:\ess\ess-VERSION\lisp\ess-site.el' will not be lost if you
     update Emacs later.

  5. Replace the line above with
          (load "C:/ess/ess-VERSION/lisp/ess-site")
     in `~/.emacs' and restart Emacs.

  6. If you see a buffer named `*ESS*', then the manual instructions
     were most likely successful.  If not, then send a query to
     <ess-help-request@stat.math.ethz.ch> explicitly describing your
     problem and your environment including operating system, Emacs
     version, ESS version, etc.

   _XEmacs Simple Instructions:_ for recent versions of XEmacs (21.x or
higher), the installation process is much simpler.  Hopefully, these
simple instructions will work for you.  If not, then more detailed,
manual instructions follow.

  1. Extract all the files from `ess-VERSION.zip' (by double clicking
     on it and selecting "Extract all files" which launches the Folders
     Extraction Wizard) into the `site-packages' directory that exists
     for packages like ESS.  If XEmacs was installed in the default
     location, then this directory can be found at `C:\Program
     Files\XEmacs\site-packages'.

  2. XEmacs requires the `HOME' environment variable to be defined.
     You can create it by visiting the following dialog: `My
     Computer->Control Panel->System->Advanced->Environment Variables'
     In the User variables window, press New.  And create a variable
     named `HOME' with a value something like (you must use forward
     slashes `/' rather than backslashes `\') `c:/Documents and
     Settings/%USERNAME%/Application Data'.  Then press OK for that
     window and press OK for the main window.  _If you also have GNU
     Emacs installed, GNU Emacs will recognize `HOME' and expand `~'
     accordingly._

  3. Now launch XEmacs and do a `C-x C-f' followed by a `~'.  From the
     Subdir menu, select Create Directory, and enter `.xemacs'

  4. Add the line
          (require 'ess-site)
     to `~/.xemacs/init.el' and restart XEmacs.

  5. If you see a buffer named `*ESS*', then the simple instructions
     were most likely successful.  If not, then read further.

  6. It could be you have an older version of XEmacs or some other
     problem with your installation.  Either way, you may need to edit
     `C:\ess\ess-VERSION\lisp\ess-site.el' manually.  If that is the
     case, then you should create a directory just for ESS like
     `C:\ess' and unpack ESS there.  That way, your changes to
     `C:\ess\ess-VERSION\lisp\ess-site.el' will not be lost if you
     update XEmacs later.

  7. Replace the line above with
          (load "C:/ess/ess-VERSION/lisp/ess-site")
     in `~/.xemacs/init.el' and restart XEmacs.

  8. If you see a buffer named `*ESS*', then the manual instructions
     were most likely successful.  If not, then send a query to
     <ess-help-request@stat.math.ethz.ch> explicitly describing your
     problem and your environment including operating system, XEmacs
     version, ESS version, etc.

   Now, you should be ready to use ESS.  For example, to edit
statistical programs, load the files with the requisite extensions
(".sas" for SAS, ".S" or "s" or "q" or "Q" for S-PLUS, ".r" or ".R" for
R, and ".lsp" for XLispStat).  One further step is needed if you wish to
run statistical processes, see below.

   To run statistical processes under ESS, Windows users will need to
make sure that the directories for the software they will be using is
in the PATH environment variable.

   On Windows NT/2000/XP, add the directories to the PATH using the `My
Computer->Control Panel->System->Advanced->Environment Variables' menu.
Note that the directory containing the program is added to the PATH,
not the program itself.  One such line is needed for each software
program.  Be sure to use the abbreviation `progra~1' and not the long
version with embedded blanks as this may cause problems.  Also, make
sure to use backslashes `\' since Windows requires them.

   An alternative, for R users, is that rather than adjusting the PATH
variable, you can add the following to your emacs initialization file
(and restart emacs):
     (setq inferior-R-program-name "c:/progra~1/R/R-2.2.1/bin/Rterm.exe")
   This assumes that you have installed R-2.2.1 in the default location.
Change the path otherwise to point to other locations.

   Windows users who place S-PLUS anywhere other than the default
location will also need to add the following three lines (properly
adjusted for their location):
     (setq-default inferior-S+6-program-name
         "c:/progra~1/Insightful/SPLUS70/cmd/Splus")
     (setq-default inferior-Sqpe+6-SHOME-name
         "c:/progra~1/Insightful/SPLUS70")
     (setq-default inferior-Sqpe+6-program-name
         "c:/progra~1/Insightful/SPLUS70/cmd/Sqpe.exe")
   The above example uses the default location of S-PLUS in
`c:\progra~1\Insightful'.  Please note that ESS considers S-PLUS 6, 7,
and 8 to be variants of S+6.

   These users may also need to modify the emacs variable
`ess-SHOME-versions' to match their installation in order to get the
full set of S-PLUS versions on their machine into the ESS menu.

   To start the S-PLUS [678].x GUI from ESS under emacs:
  1. If you use Cygwin bash as your primary shell, then
          M-x S
          (or `M-x S+6').

  2. If you use the MSDOS prompt window as your primary shell, then
          M-x S+6-msdos
     You will then be asked for a pathname ("S starting data
directory?"), from which to start the process.  The prompt will propose
your current directory as the default.  ESS will start the S-PLUS GUI.
There will be slight delay during which emacs is temporarily frozen.
ESS will arrange for communication with the S-PLUS GUI using the DDE
protocol.  Send lines or regions from the emacs buffer containing your
S program (for example, `myfile.s') to the S-PLUS Commands Window with
the `C-c C-n' or `C-c C-r' keys.  (If you are still using S-PLUS 4.x or
2000,\ then use `M-x S+4' or `M-x S+4-msdos'.)

   To start an S-PLUS [678].x session inside an emacs buffer--and
without the S-PLUS GUI:
     M-x Sqpe
     (or `M-x Sqpe+6').
   This works with both the bash and msdos shells.  You will then be
asked for a pathname ("S starting data directory?"), from which to
start the process.  The prompt will propose your current directory as
the default.  You get Unix-like behavior, in particular the entire
transcript is available for emacs-style search commands.  Send lines or
regions from the emacs buffer containing your S program (for example,
`myfile.s') to the *S+6* buffer with the `C-c C-n' or `C-c C-r' keys.
Interactive graphics are available with Sqpe by using the java library
supplied with S-PLUS 6.1 and newer releases.  Enter the commands:
     library(winjava)
     java.graph()
   Graphs can be saved from the `java.graph' device in several formats,
but not PostScript.   If you need a PostScript file you will need to
open a separate `postscript' device.  (If you are still using S-PLUS
4.x or 2000, then use `M-x Sqpe+4'.)

   To connect to an already running S-PLUS GUI (started, for example,
from the S-PLUS icon):
     M-x S+6-existing
   or
     M-x S+6-msdos-existing
   You will then be asked for a pathname ("S starting data
directory?"), from which to start the process.  The prompt will propose
your current directory as the default.  ESS will arrange for
communication with the already running S-PLUS GUI using the DDE
protocol.  Send lines or regions from the emacs buffer containing your
S program (for example, `myfile.s') to the S-PLUS Commands Window with
the `C-c C-n' or `C-c C-r' keys.  (If you are still using S-PLUS 4.x or
2000,  then use `M-x S+4-existing' or `M-x S+4-msdos-existing'.)

   If you wish to run R, you can start it with:
     M-x R

   XLispStat can not currently be run with
     M-x XLS
   Hopefully, this will change.  However, you can still edit with
emacs, and cut and paste the results into the XLispStat *Listener*
Window under Microsoft Windows.


File: ess.info,  Node: Requirements,  Prev: Microsoft Windows installation,  Up: Installation

Requirements
============

   ESS is most likely to work with current/recent versions of the
following statistical packages: R/S-PLUS, SAS, Stata and JAGS. The one
exception is BUGS which is quite old, but should still work.

   ESS supports current/recent versions of GNU Emacs and XEmacs.  Most
notably, the GNU Emacs 22 series and XEmacs 21.4.14 or higher
(beta/pre-release versions are NOT SUPPORTED).


File: ess.info,  Node: Interactive ESS,  Next: Entering commands,  Prev: Installation,  Up: Top

Interacting with statistical programs
*************************************

   As well as using ESS to edit your source files for statistical
programs, you can use ESS to run these statistical programs.  In this
chapter, we mostly will refer by example to running S from within
emacs.  The emacs convention is to name such processes running under
its control as `inferior processes'.  This term can be slightly
misleading, in which case these processes can be thought of
`interactive processes'.  Either way, we use the term `iESS' to refer
to the Emacs mode used to interact with statistical programs.

* Menu:

* Starting up::
* Multiple ESS processes::
* ESS processes on Remote Computers::
* S+elsewhere and ESS-elsewhere::
* Customizing startup::


File: ess.info,  Node: Starting up,  Next: Multiple ESS processes,  Prev: Interactive ESS,  Up: Interactive ESS

Starting an ESS process
=======================

   To start an S session on Unix or on Windows when you use the Cygwin
bash shell, simply type `M-x S RET'.

   To start an S session on Windows when you use the MSDOS prompt
shell, simply type `M-x S+6-msdos RET'.

   S will then (by default) ask the question
     S starting data directory?

Enter the name of the directory you wish to start S from (that is, the
directory you would have `cd''d to before starting S from the shell).
This directory should have a `.Data' subdirectory.

   You will then be popped into a buffer with name `*S*' which will be
used for interacting with the ESS process, and you can start entering
commands.


File: ess.info,  Node: Multiple ESS processes,  Next: ESS processes on Remote Computers,  Prev: Starting up,  Up: Interactive ESS

Running more than one ESS process
=================================

   ESS allows you to run more than one ESS process simultaneously in the
same session.  Each process has a name and a number; the initial process
(process 1) is simply named (using S-PLUS as an example) `S+3:1'.  The
name of the process is shown in the mode line in square brackets (for
example, `[S+3:2]'); this is useful if the process buffer is renamed.
Without a prefix argument, `M-x S' starts a new ESS process, using the
first available process number.  With a prefix argument (for R), `C-u
M-x R' allows for the specification of command line options.

   You can switch to any active ESS process with the command `M-x
ess-request-a-process'.  Just enter the name of the process you
require; completion is provided over the names of all running S
processes.  This is a good command to consider binding to a global key.


File: ess.info,  Node: ESS processes on Remote Computers,  Next: S+elsewhere and ESS-elsewhere,  Prev: Multiple ESS processes,  Up: Interactive ESS

ESS processes on Remote Computers
=================================

   ESS works with processes on remote computers as easily as with
processes on the local machine.  The recommended way to access a
statistical program on remote computer is to start it from a telnet or
ssh buffer and then connect ESS to that buffer.

  1. Start a new telnet or ssh buffer and connect to the remote computer
     (e.g. use `M-x telnet' or `M-x ssh'; ssh.el is available at
     `ftp://ftp.splode.com/pub/users/friedman/emacs-lisp/ssh.el').

  2. Start the ESS process on the remote machine, for example with one
     of the commands `Splus', or `R', or `sas -stdio'.

  3. Enter the ESS command `M-x ess-remote'.  You will be prompted for
     a program name.  Enter `sp6' or `r' or `sas' or another valid
     name.  Your telnet process is now known to ESS.  All the usual ESS
     commands (`C-c C-n' and its relatives) now work with the S
     language processes.  For SAS you need to use a different command
     `C-c i' (that is a regular `i', not a `C-i') to send lines from
     your `myfile.sas' to the remote SAS process.  `C-c i' sends lines
     over invisibly.  With ess-remote you get teletype behavior--the
     data input, the log, and the listing all appear in the same
     buffer.  To make this work, you need to end every PROC and DATA
     step with a "RUN;" statement.  The "RUN;" statement is what tells
     SAS that it should process the preceding input statements.

  4. Graphics (interactive) on the remote machine.  If you run X11
     (*Note X11::, X-windows) on both the local and remote machines
     then you should be able to display the graphs locally by setting
     the `DISPLAY' environment variable appropriately.  Windows users
     can download `xfree86' from cygwin.

  5. Graphics (static) on the remote machine.  If you don't run the X
     window system on the local machine, then you can write graphics to
     a file on the remote machine, and display the file in a graphics
     viewer on the local machine.  Most statistical software can write
     one or more of postscript, GIF, or JPEG files.  Depending on the
     versions of emacs and the operating system that you are running,
     emacs itself may display `.gif' and `.jpg' files.  Otherwise, a
     graphics file viewer will be needed.  Ghostscript/ghostview may be
     downloaded to display `.ps' and `.eps' files.  Viewers for GIF and
     JPEG are usually included with operating systems.  *Note
     ESS(SAS)--Function keys for batch processing::, for more
     information on using the F12 key for displaying graphics files
     with SAS.

   Should you or a colleague inadvertently start a statistical process
in an ordinary `*shell*' buffer, the `ess-remote' command can be used
to convert it to an ESS buffer and allow you to use the ESS commands
with it.

   We have two older commands, now deprecated, for accessing ESS
processes on remote computers.  *Note S+elsewhere and ESS-elsewhere::.


File: ess.info,  Node: S+elsewhere and ESS-elsewhere,  Next: Customizing startup,  Prev: ESS processes on Remote Computers,  Up: Interactive ESS

S+elsewhere and ESS-elsewhere
=============================

   These commands are now deprecated.  We recommend `ess-remote'.  We
have two versions of the elsewhere function.  `S+elsewhere' is specific
for the S-Plus program.  The more general function `ESS-elsewhere' is
not as stable.

  1. Enter `M-x S+elsewhere'.  You will be prompted for a starting
     directory.  I usually give it my project directory on the local
     machine, say  `~myname/myproject/'

     Or enter `M-x ESS-elsewhere'.  You will be prompted for an ESS
     program and for a starting directory.  I usually give it my project
     directory on the local machine, say `~myname/myproject/'

  2. The `*S+3*' buffer will appear with a prompt from the local
     operating system (the unix prompt on a unix workstation or with
     cygwin bash on a PC, or the msdos prompt on a PC without bash).
     emacs may freeze because the cursor is at the wrong place.
     Unfreeze it with `C-g' then move the cursor to the end with `M->'.
     With `S+elsewhere' the buffer name is based on the name of the ESS
     program.

  3. Enter `telnet myname@other.machine' (or `ssh
     myname@other.machine').  You will be prompted for your password on
     the remote machine.  Use `M-x send-invisible' before typing the
     password itself.

  4. Before starting the ESS process, type `stty -echo nl' at the unix
     prompt.  The `-echo' turns off the echo, the `nl' turns off the
     newline that you see as `^M'.

  5. You are now talking to the unix prompt on the other machine in the
     `*S+3*' buffer.  cd into the directory for the current project and
     start the ESS process by entering `Splus' or `R' or `sas -stdio'
     as appropriate.  If you can login remotely to your Windows 2000,
     then you should be able to run `Sqpe' on the Windows machine.  I
     haven't tested this and noone has reported their tests to me.  You
     will not be able to run the GUI through this text-only connection.

  6. Once you get the S or R or SAS prompt, then you are completely
     connected.  All the `C-c C-n' and related commands work correctly
     in sending commands from `myfile.s' or `myfile.r' on the PC to the
     `*S+3*' buffer running the S or R or SAS program on the remote
     machine.

  7. Graphics on the remote machine works fine.  If you run the X window
     system on the remote unix machine you should be able to display
     them in `xfree86' on your PC.  If you don't run X11, then you can
     write graphics to the postscript device and copy it to your PC
     with dired and display it with ghostscript.


File: ess.info,  Node: Customizing startup,  Prev: S+elsewhere and ESS-elsewhere,  Up: Interactive ESS

Changing the startup actions
============================

   If you do not wish ESS to prompt for a starting directory when
starting a new process, set the variable `ess-ask-for-ess-directory' to
`nil'.  In this case, the starting directory will be set using one of
the following methods:

  1. If the variable `ess-directory-function' stores the name of a
     function, the value returned by this function is used.  The
     default for this variable is nil.

  2. Otherwise, if the variable `ess-directory' stores the name of a
     directory (ending in a slash), this value is used.  The default
     for this variable is nil.

  3. Otherwise, the working directory of the current buffer is used.


   If `ess-ask-for-ess-directory' has a non-`nil' value (as it does by
default) then the value determined by the above rules provides the
default when prompting for the starting directory.  Incidentally,
`ess-directory' is an ideal variable to set in `ess-pre-run-hook'.

   If you like to keep a record of your S sessions, set the variable
`ess-ask-about-transfile' to `t', and you will be asked for a filename
for the transcript before the ESS process starts.

 - User Option: ess-ask-about-transfile
     If non-`nil', as for a file name in which to save the session
     transcript.

   Enter the name of a file in which to save the transcript at the
prompt.  If the file doesn't exist it will be created (and you should
give it a file name ending in `.St'); if the file already exists the
transcript will be appended to the file.  (Note: if you don't set this
variable but you still want to save the transcript, you can still do it
later -- *note Saving transcripts::.)

   Once these questions are answered (if they are asked at all) the S
process itself is started by calling the program name specified in the
variable `inferior-ess-program'.  If you need to pass any arguments to
this program, they may be specified in the variable
`inferior-S_PROGRAM_NAME-args' (e.g. if `inferior-ess-program' is
`"S+"' then the variable to set is `inferior-S+-args'.  It is not
normally necessary to pass arguments to the S program; in particular do
not pass the `-e' option to `Splus', since ESS provides its own command
history mechanism.

   By default, the new process will be displayed in the same window in
the current frame.  If you wish your S process to appear in a separate
variable, customize the variable `inferior-ess-own-frame'.
Alternatively, change `inferior-ess-same-window' if you wish the
process to appear within another window of the current frame.


File: ess.info,  Node: Entering commands,  Next: Transcript Mode,  Prev: Interactive ESS,  Up: Top

Interacting with the ESS process
********************************

   The primary function of the ESS package is to provide an easy-to-use
front end to the S interpreter.  This is achieved by running the S
process from within an Emacs buffer, so that the Emacs editing commands
are available to correct mistakes in commands, etc.  The features of
Inferior S mode are similar to those provided by the standard Emacs
shell mode (*note Shell Mode: (emacs)Shell Mode.).  Command-line
completion of S objects and a number of `hot keys' for commonly-used S
commands are also provided for ease of typing.

* Menu:

* Command-line editing::        Entering commands and fixing mistakes
* Completion::                  Completion of object names
* Completion details::          Advanced completion concepts
* Transcript::                  Manipulating the transcript
* Command History::             Command History
* History expansion::           References to historical commands
* Hot keys::                    Hot keys for common commands
* Statistical Process running in ESS?::
* Emacsclient::                 Using emacsclient
* Other::                       Other commands provided by inferior-ESS


File: ess.info,  Node: Command-line editing,  Next: Completion,  Prev: Entering commands,  Up: Entering commands

Entering commands and fixing mistakes
=====================================

   Sending a command to the ESS process is as simple as typing it in
and pressing the <RETURN> key:

   * `RET' (`inferior-ess-send-input')
     Send the command on the current line to the ESS process.

   If you make a typing error before pressing `RET' all the usual Emacs
editing commands are available to correct it (*note Basic:
(emacs)Basic.).  Once the command has been corrected you can press
<RETURN> (even if the cursor is not at the end of the line) to send the
corrected command to the ESS process.

   ESS provides some other commands which are useful for fixing
mistakes:

   * `C-c C-w' (`backward-kill-word')
     Deletes the previous word (such as an object name) on the command
     line.

   * `C-c C-u' (`comint-kill-input')
     Deletes everything from the prompt to point.  Use this to abandon a
     command you have not yet sent to the ESS process.

   * `C-c C-a' (`comint-bol')
     Move to the beginning of the line, and then skip forwards past the
     prompt, if any.

   *Note Shell Mode: (emacs)Shell Mode, for other commands relevant to
entering input.


File: ess.info,  Node: Completion,  Next: Completion details,  Prev: Command-line editing,  Up: Entering commands

Completion of object names
==========================

   In the process buffer, the <TAB> key is for completion, similar to
that provided by Shell Mode for filenames.  In Inferior S mode,
pressing the <TAB> key when the cursor is following the first few
characters of an object name _completes_ the object name; if the cursor
is following a file name `TAB' completes the file name.

   * `TAB' (`comint-dynamic-complete')
     Complete the S object name or filename before point.

   When the cursor is just after a partially-completed object name,
pressing <TAB> provides completion in a similar fashion to `tcsh'
except that completion is performed over all known S object names
instead of file names.  ESS maintains a list of all objects known to S
at any given time, which basically consists of all objects (functions
and datasets) in every attached directory listed by the `search()'
command along with the component objects of attached data frames (if
your version of S supports them).

   For example, consider the three functions (available in Splus version
3.0) called `binomplot()', `binom.test()' and `binomial()'.  Typing
`bin TAB' after the S prompt will insert the characters `om',
completing the longest prefix (`binom') which distinguishes these three
commands.  Pressing `TAB' once more provides a list of the three
commands which have this prefix, allowing you to add more characters
(say, `.') which specify the function you desire.  After entering more
characters pressing `TAB' yet again will complete the object name up to
uniqueness, etc.  If you just wish to see what completions exist without
adding any extra characters, type `M-?'.

   * `M-?' (`ess-list-object-completions')
     List all possible completions of the object name at point.

   ESS also provides completion over the components of named lists
accessed using the `$' notation, to any level of nested lists.  This
feature is particularly useful for checking what components of a list
object exist while partway through entering a command: simply type the
object name and `$' and press `TAB' to see the names of existing list
components for that object.

   Completion is also provided over file names, which is particularly
useful when using S functions such as `get()' or `scan()' which require
fully expanded file names.  Whenever the cursor is within an S string,
pressing `TAB' completes the file name before point, and also expands
any `~' or environment variable references.

   If the cursor is not in a string and does not follow a (partial)
object name, the <TAB> key has a third use: it expands history
references.  *Note History expansion::.


File: ess.info,  Node: Completion details,  Next: Transcript,  Prev: Completion,  Up: Entering commands

Completion details
==================

   ESS automatically keeps track of any objects added or deleted to the
system (such as new objects created, or directories added to the search
list) to make completion as accurate as possible.  Whenever ESS notices
that search list has changed (1)  when you attach a directory or data
frame, the objects associated with it immediately become available for a
completion; when it is detached completion is no longer available on
those objects.

   To maintain a list of accessible objects for completion, ESS needs to
determine which objects are contained in each directory or data frame on
the search list.  This is done at the start of each S session, by
running the `objects()' command on every element of the search list.

   Efficiency in completion is gained by maintaining a cache of objects
currently known to S; when a new object becomes available or is deleted,
only one component of the cache corresponding to the associated
directory needs to be refreshed.  If ESS ever becomes confused about
what objects are available for completion (such as when if refuses to
complete an object you *know* is there), the command `M-x ess-resynch'
forces the _entire_ cache to be refreshed, which should fix the problem.

   ---------- Footnotes ----------

   (1) The variable `ess-change-sp-regexp' is a regular expression
matching commands which change the search list.  You will need to
modify this variable if you have defined custom commands (other than
`attach', `detach', `collection' or `library') which modify the search
list.


File: ess.info,  Node: Transcript,  Next: Command History,  Prev: Completion details,  Up: Entering commands

Manipulating the transcript
===========================

   Most of the time, the cursor spends most of its time at the bottom of
the ESS process buffer, entering commands.  However all the input and
output from the current (and previous) ESS sessions is stored in the
process buffer (we call this the transcript) and often we want to move
back up through the buffer, to look at the output from previous
commands for example.

   Within the process buffer, a paragraph is defined as the prompt, the
command after the prompt, and the output from the command.  Thus `M-{'
and `M-}' move you backwards and forwards, respectively, through
commands in the transcript.  A particularly useful command is `M-h'
(`mark-paragraph') which will allow you to mark a command and its
entire output (for deletion, perhaps).  For more information about
paragraph commands, *note Paragraphs: (emacs)Paragraphs..

   If an ESS process finishes and you restart it in the same process
buffer, the output from the new ESS process appears after the output
from the first ESS process separated by a form-feed (`^L') character.
Thus pages in the ESS process buffer correspond to ESS sessions.  Thus,
for example, you may use `C-x [' and `C-x ]' to move backward and
forwards through ESS sessions in a single ESS process buffer.  For more
information about page commands, *note Pages: (emacs)Pages..

* Menu:

* Last command::                Manipulating the output from the last command
* Process buffer motion::       Viewing older commands
* Transcript resubmit::         Re-submitting commands from the transcript
* Saving transcripts::          Keeping a record of your S session


File: ess.info,  Node: Last command,  Next: Process buffer motion,  Prev: Transcript,  Up: Transcript

Manipulating the output from the last command
---------------------------------------------

   Viewing the output of the command you have just entered is a common
occurrence and ESS provides a number of facilities for doing this.
Whenever a command produces a longish output, it is possible that the
window will scroll, leaving the next prompt near the middle of the
window.  The first part of the command output may have scrolled off the
top of the window, even though the entire output would fit in the window
if the prompt were near the bottom of the window.  If this happens, you
can use the command

   * `C-c C-e' (`comint-show-maximum-output')
     Move to the end of the buffer, and place cursor on bottom line of
     window.

to make more of the last output visible.  (To make this happen
automatically for all inputs, set the variable
`comint-scroll-to-bottom-on-input' to `t'.)

   If the first part of the output is still obscured, use
   * `C-c C-r' (`comint-show-output')
     Moves cursor to the previous command line and and places it at the
     top of the window.

to view it.  Finally, if you want to discard the last command output
altogether, use

   * `C-c C-o' (`comint-kill-output')
     Deletes everything from the last command to the current prompt.

to delete it.  Use this command judiciously to keep your transcript to a
more manageable size.


File: ess.info,  Node: Process buffer motion,  Next: Transcript resubmit,  Prev: Last command,  Up: Transcript

Viewing older commands
----------------------

   If you want to view the output from more historic commands than the
previous command, commands are also provided to move backwards and
forwards through previously entered commands in the process buffer:

   * `C-c C-p' (`comint-previous-input')
     Moves point to the preceding command in the process buffer.

   * `C-c C-n' (`comint-next-input')
     Moves point to the next command in the process buffer.

Note that these two commands are analogous to `C-p' and `C-n' but apply
to command lines rather than text lines.  And just like `C-p' and
`C-n', passing a prefix argument to these commands means to move to the
ARG'th next (or previous) command.  (These commands are also discussed
in *Note Shell History Copying: (emacs)Shell History Copying.)

   There are also two similar commands (not bound to any keys by
default) which move to preceding or succeeding commands, but which
first prompt for a regular expression (*note Syntax of Regular
Expression: (emacs)Regexps.), and then moves to the next (previous)
command matching the pattern.

   * `(comint-backward-matching-input regexp arg)'
     `(comint-forward-matching-input regexp arg)'
     Search backward (forward) through the transcript buffer for the
     ARG'th previous (next) command matching REGEXP.  ARG is the prefix
     argument; REGEXP is prompted for in the minibuffer.


File: ess.info,  Node: Transcript resubmit,  Next: Saving transcripts,  Prev: Process buffer motion,  Up: Transcript

Re-submitting commands from the transcript
------------------------------------------

   When moving through the transcript, you may wish to re-execute some
of the commands you find there.  ESS provides three commands to do this;
these commands may be used whenever the cursor is within a command line
in the transcript (if the cursor is within some command _output_, an
error is signalled).  Note all three commands involve the <RETURN> key.

   * `RET' (`inferior-ess-send-input')
     Copy the command under the cursor to the current command line, and
     execute it.

   * `C-c RET' (`comint-copy-old-input')
     Copy the command under the cursor to the current command line, but
     don't execute it.  Leaves the cursor on the command line so that
     the copied command may be edited.

   * `M-RET' (`ess-transcript-send-command-and-move')
     Copy the command under the cursor to the current command line, and
     execute it.  Moves the cursor to the following command.

   When the cursor is not after the current prompt, the <RETURN> key
has a slightly different behavior than usual.  Pressing `RET' on any
line containing a command that you entered (i.e. a line beginning with a
prompt) sends that command to the ESS process once again.  If you wish
to edit the command before executing it, use `C-c RET' instead; it
copies the command to the current prompt but does not execute it,
allowing you to edit it before submitting it.

   These two commands leave the cursor at the new command line, allowing
you to continue with interactive use of S.  If you wish to resubmit a
series of commands from the transcript, consider using `M-RET' instead,
which leaves the cursor at the command line following the one you
re-submitted.  Thus by using `M-RET' repeatedly, you can re-submit a
whole series of commands.

   These commands work even if if the current line is a continuation
line (i.e. the prompt is `+' instead of `>') -- in this case all the
lines that form the multi-line command are concatenated together and
the resulting command is sent to the ESS process (currently this is the
only way to resubmit a multi-line command to the ESS process in one
go).  If the current line does not begin with a prompt, an error is
signalled.  This feature, coupled with the command-based motion
commands described above, could be used as a primitive history
mechanism.  ESS provides a more sophisticated mechanism, however, which
is described in *Note Command History::.


File: ess.info,  Node: Saving transcripts,  Prev: Transcript resubmit,  Up: Transcript

Keeping a record of your S session
----------------------------------

   To keep a record of your S session in a disk file, use the Emacs
command `C-x C-w' (`write-file') to attach a file to the ESS process
buffer.  The name of the process buffer will (probably) change to the
name of the file, but this is not a problem.  You can still use S as
usual; just remember to save the file before you quit Emacs with `C-x
C-s'.  You can make ESS prompt you for a filename in which to save the
transcript every time you start S by setting the variable
`ess-ask-about-transfile' to `t'; see *Note Customizing startup::.  We
recommend you save your transcripts with filenames that end in `.St'.
There is a special mode (ESS transcript mode -- *note Transcript
Mode::) for editing transcript files which is automatically selected
for files with this suffix.

   S transcripts can get very large, so some judicious editing is
appropriate if you are saving it in a file.  Use `C-c C-o' whenever a
command produces excessively long output (printing large arrays, for
example).  Delete erroneous commands (and the resulting error messages
or other output) by moving to the command (or its output) and typing
`M-h C-w'.  Also, remember that `C-c C-e' (and other hot keys) may be
used for commands whose output you do not wish to appear in the
transcript.  These suggestions are appropriate even if you are not
saving your transcript to disk, since the larger the transcript, the
more memory your Emacs process will use on the host machine.

   Finally, if you intend to produce S source code (suitable for using
with `source()' or inclusion in an S function) from a transcript, then
the command `M-x ess-transcript-clean-region' may be of use.  This
command works in any Emacs buffer, and removes all prompts and command
output from an ESS transcript within the current region, leaving only
the commands.  Don't forget to remove any erroneous commands first!


File: ess.info,  Node: Command History,  Next: History expansion,  Prev: Transcript,  Up: Entering commands

Command History
===============

   ESS provides easy-to-use facilities for re-executing or editing
previous commands.  An input history of the last few commands is
maintained (by default the last 50 commands are stored, although this
can be changed by setting the variable `comint-input-ring-size' in
`inferior-ess-mode-hook'.) The simplest history commands simply select
the next and previous commands in the input history:

   * `M-p' (`comint-previous-input')
     Select the previous command in the input history.

   * `M-n'  (`comint-next-input')
     Select the next command in the input history.

For example, pressing `M-p' once will re-enter the last command into
the process buffer after the prompt but does not send it to the ESS
process, thus allowing editing or correction of the command before the
ESS process sees it.  Once corrections have been made, press `RET' to
send the edited command to the ESS process.

   If you want to select a particular command from the history by
matching it against a regular expression (*note Syntax of Regular
Expression: (emacs)Regexps.), to search for a particular variable name
for example, these commands are also available:

   * `M-r' (`comint-previous-matching-input')
     Prompt for a regular expression, and search backwards through the
     input history for a command matching the expression.

   * `M-s' (`comint-next-matching-input')
     Prompt for a regular expression, and search backwards through the
     input history for a command matching the expression.

A common type of search is to find the last command that began with a
particular sequence of characters; the following two commands provide an
easy way to do this:

   * `A-M-r' (`comint-previous-matching-input-from-input')
     Select the previous command in the history which matches the string
     typed so far.

   * `A-M-s' (`comint-next-matching-input-from-input')
     Select the next command in the history which matches the string
     typed so far.

Instead of prompting for a regular expression to match against, as they
instead select commands starting with those characters already entered.
For instance, if you wanted to re-execute the last `attach()' command,
you may only need to type `att' and then `A-M-r' and `RET'.  (Note: you
may not have an <ALT> key on your keyboard, in which case it may be a
good idea to bind these commands to some other keys.)

   *Note Shell History Ring: (emacs)Shell Ring, for a more detailed
discussion of the history mechanism.

